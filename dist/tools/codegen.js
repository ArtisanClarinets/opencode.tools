"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.scaffold = scaffold;
exports.generateFeature = generateFeature;
exports.generateTests = generateTests;
/**
 * Code Generation Tool - Real Code Scaffolding
 *
 * Generates:
 * - Project scaffolding for various stacks
 * - Feature implementations
 * - API endpoints
 * - Database models
 */
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const audit_1 = require("./audit");
const RUN_ID = 'mock-run-123';
/**
 * Generate package.json for various stacks
 */
function generatePackageJson(projectName, stack) {
    const base = {
        name: projectName,
        version: '1.0.0',
        description: `${projectName} - Generated by OpenCode Tools`,
        scripts: {},
        dependencies: {},
        devDependencies: {}
    };
    switch (stack) {
        case 'Next.js':
            base.scripts = {
                'dev': 'next dev',
                'build': 'next build',
                'start': 'next start',
                'lint': 'next lint',
                'test': 'jest'
            };
            base.dependencies = {
                'next': '^14.0.0',
                'react': '^18.2.0',
                'react-dom': '^18.2.0'
            };
            base.devDependencies = {
                'typescript': '^5.0.0',
                '@types/node': '^20.0.0',
                '@types/react': '^18.2.0',
                'eslint': '^8.0.0',
                'eslint-config-next': '^14.0.0',
                'jest': '^29.0.0',
                '@testing-library/react': '^14.0.0'
            };
            break;
        case 'NestJS':
            base.scripts = {
                'build': 'nest build',
                'start': 'nest start',
                'start:dev': 'nest start --watch',
                'test': 'jest',
                'lint': 'eslint "src/**/*.ts"'
            };
            base.dependencies = {
                '@nestjs/core': '^10.0.0',
                '@nestjs/common': '^10.0.0',
                '@nestjs/platform-express': '^10.0.0',
                'reflect-metadata': '^0.1.0',
                'rxjs': '^7.0.0'
            };
            base.devDependencies = {
                '@nestjs/cli': '^10.0.0',
                '@nestjs/testing': '^10.0.0',
                'typescript': '^5.0.0',
                'jest': '^29.0.0',
                '@types/node': '^20.0.0',
                'eslint': '^8.0.0'
            };
            break;
        case 'Express':
            base.scripts = {
                'dev': 'ts-node src/index.ts',
                'build': 'tsc',
                'start': 'node dist/index.js',
                'test': 'jest'
            };
            base.dependencies = {
                'express': '^4.18.0',
                'cors': '^2.8.5',
                'helmet': '^7.0.0',
                'morgan': '^1.10.0',
                'dotenv': '^16.0.0'
            };
            base.devDependencies = {
                'typescript': '^5.0.0',
                '@types/express': '^4.17.0',
                '@types/node': '^20.0.0',
                'ts-node': '^10.9.0',
                'jest': '^29.0.0',
                'supertest': '^6.3.0',
                '@types/supertest': '^2.0.0',
                'eslint': '^8.0.0',
                '@typescript-eslint/eslint-plugin': '^6.0.0',
                '@typescript-eslint/parser': '^6.0.0'
            };
            break;
        default:
            base.scripts = {
                'dev': 'ts-node src/index.ts',
                'build': 'tsc',
                'test': 'jest'
            };
            base.dependencies = {};
            base.devDependencies = {
                'typescript': '^5.0.0',
                '@types/node': '^20.0.0',
                'jest': '^29.0.0'
            };
    }
    return JSON.stringify(base, null, 2);
}
/**
 * Generate tsconfig.json
 */
function generateTsconfig() {
    return JSON.stringify({
        compilerOptions: {
            target: 'ES2020',
            module: 'commonjs',
            lib: ['ES2020'],
            outDir: './dist',
            rootDir: './src',
            strict: true,
            esModuleInterop: true,
            skipLibCheck: true,
            forceConsistentCasingInFileNames: true,
            resolveJsonModule: true,
            declaration: true,
            declarationMap: true,
            sourceMap: true
        },
        include: ['src/**/*'],
        exclude: ['node_modules', 'dist', '**/*.test.ts']
    }, null, 2);
}
/**
 * Generate main entry file based on stack
 */
function generateMainEntry(stack, options) {
    switch (stack) {
        case 'Next.js':
            return `import { NextPage } from 'next';

const Home: NextPage = () => {
  return (
    <div>
      <h1>${options.projectName}</h1>
      <p>Welcome to your new Next.js application</p>
    </div>
  );
};

export default Home;
`;
        case 'NestJS':
            return `import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
  console.log(\`Application is running on: http://localhost:3000\`);
}
bootstrap();
`;
        case 'Express':
            return `import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(helmet());
app.use(cors());
app.use(morgan('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// TODO: Add routes here

// Error handler
app.use((err: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Something went wrong!' });
});

app.listen(PORT, () => {
  console.log(\`Server running on http://localhost:\${PORT}\`);
});

export default app;
`;
        default:
            return `// ${options.projectName} - Main entry point
console.log('Hello from ${options.projectName}');
`;
    }
}
/**
 * Generate basic test file
 */
function generateTestFile(stack, filename) {
    switch (stack) {
        case 'Next.js':
            return `import { render, screen } from '@testing-library/react';
import Home from '../pages/index';

describe('Home Page', () => {
  it('renders without crashing', () => {
    render(<Home />);
    expect(screen.getByText(/Welcome/)).toBeInTheDocument();
  });
});
`;
        case 'NestJS':
            return `import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';

describe('AppController', () => {
  let controller: AppController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
    }).compile();

    controller = module.get<AppController>(AppController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
`;
        case 'Express':
            return `import request from 'supertest';
import app from '../src/index';

describe('API Tests', () => {
  describe('GET /health', () => {
    it('should return health status', async () => {
      const response = await request(app).get('/health');
      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('status', 'ok');
    });
  });
});
`;
        default:
            return `describe('${filename}', () => {
  it('should pass', () => {
    expect(true).toBe(true);
  });
});
`;
    }
}
/**
 * Generate Dockerfile
 */
function generateDockerfile(stack, projectName) {
    const baseImage = stack === 'Next.js' ? 'node:18-alpine' : 'node:20-alpine';
    return `# Generated by OpenCode Tools
FROM ${baseImage} AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./
RUN npm ci

# Copy source
COPY . .
RUN npm run build

# Production image
FROM ${baseImage} AS production

WORKDIR /app

# Copy built artifacts
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY package*.json ./

ENV NODE_ENV=production

EXPOSE 3000

CMD ["node", "dist/index.js"]
`;
}
/**
 * Generate .gitignore
 */
function generateGitignore() {
    return `# Dependencies
node_modules/
.pnp
.pnp.js

# Build outputs
dist/
build/
.next/
out/

# Testing
coverage/

# Environment
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Testing
.jest-cache/
`;
}
/**
 * Scaffold a new project
 */
async function scaffold(stack, structure) {
    console.log(`[Codegen.scaffold] Scaffolding ${stack} project.`);
    const outputDir = structure.outputDir || path.join(process.cwd(), structure.projectName);
    if (fs.existsSync(outputDir)) {
        throw new Error(`Directory already exists: ${outputDir}`);
    }
    fs.mkdirSync(outputDir, { recursive: true });
    fs.mkdirSync(path.join(outputDir, 'src'), { recursive: true });
    fs.mkdirSync(path.join(outputDir, 'tests'), { recursive: true });
    const files = [];
    // Generate package.json
    const pkgPath = path.join(outputDir, 'package.json');
    fs.writeFileSync(pkgPath, generatePackageJson(structure.projectName, stack));
    files.push(pkgPath);
    // Generate tsconfig.json
    const tsconfigPath = path.join(outputDir, 'tsconfig.json');
    fs.writeFileSync(tsconfigPath, generateTsconfig());
    files.push(tsconfigPath);
    // Generate main entry
    const srcPath = path.join(outputDir, 'src', 'index.ts');
    fs.writeFileSync(srcPath, generateMainEntry(stack, structure));
    files.push(srcPath);
    // Generate test file
    const testPath = path.join(outputDir, 'tests', 'index.test.ts');
    fs.writeFileSync(testPath, generateTestFile(stack, 'main'));
    files.push(testPath);
    // Generate .gitignore
    const gitignorePath = path.join(outputDir, '.gitignore');
    fs.writeFileSync(gitignorePath, generateGitignore());
    files.push(gitignorePath);
    // Generate Dockerfile if requested
    if (structure.options?.withDocker) {
        const dockerPath = path.join(outputDir, 'Dockerfile');
        fs.writeFileSync(dockerPath, generateDockerfile(stack, structure.projectName));
        files.push(dockerPath);
        const dockerignorePath = path.join(outputDir, '.dockerignore');
        fs.writeFileSync(dockerignorePath, 'node_modules\n.git\ndist\ncoverage');
        files.push(dockerignorePath);
    }
    // Generate README
    const readmePath = path.join(outputDir, 'README.md');
    fs.writeFileSync(readmePath, `# ${structure.projectName}

Generated by OpenCode Tools

## Getting Started

\`\`\`bash
npm install
npm run dev
\`\`\`

## Available Scripts

- \`npm run dev\` - Start development server
- \`npm run build\` - Build for production
- \`npm test\` - Run tests
`);
    files.push(readmePath);
    const summary = `# Scaffold Complete

## Project: ${structure.projectName}
## Stack: ${stack}

### Files Created
${files.map(f => `- ${path.relative(outputDir, f)}`).join('\n')}

### Next Steps
1. cd ${structure.projectName}
2. npm install
3. npm run dev
`;
    await (0, audit_1.logToolCall)(RUN_ID, 'codegen.scaffold', {
        stack,
        projectName: structure.projectName
    }, {
        file_count: files.length
    });
    return { success: true, files, summary };
}
/**
 * Generate feature code
 */
async function generateFeature(story, existingFiles) {
    console.log(`[Codegen.generateFeature] Implementing feature: ${story.title || story.id}`);
    const featureName = story.title?.toLowerCase().replace(/\s+/g, '-') || 'feature';
    const outputDir = path.join(process.cwd(), 'src', 'features', featureName);
    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }
    const files = [];
    // Generate feature module
    const moduleContent = `// Feature: ${story.title}
export interface ${pascalCase(featureName)}Config {
    enabled: boolean;
}

export class ${pascalCase(featureName)}Feature {
    private config: ${pascalCase(featureName)}Config;
    
    constructor(config: ${pascalCase(featureName)}Config) {
        this.config = config;
    }
    
    async execute(input: any): Promise<any> {
        if (!this.config.enabled) {
            throw new Error('Feature is disabled');
        }
        
        // TODO: Implement feature logic
        return { success: true, data: input };
    }
}

export default ${pascalCase(featureName)}Feature;
`;
    const modulePath = path.join(outputDir, 'index.ts');
    fs.writeFileSync(modulePath, moduleContent);
    files.push({ path: modulePath, content: moduleContent });
    // Generate test
    const testContent = `import { ${pascalCase(featureName)}Feature } from './index';

describe('${pascalCase(featureName)}Feature', () => {
    let feature: ${pascalCase(featureName)}Feature;
    
    beforeEach(() => {
        feature = new ${pascalCase(featureName)}Feature({ enabled: true });
    });
    
    it('should execute successfully', async () => {
        const result = await feature.execute({ test: true });
        expect(result.success).toBe(true);
    });
    
    it('should throw when disabled', async () => {
        const disabledFeature = new ${pascalCase(featureName)}Feature({ enabled: false });
        await expect(disabledFeature.execute({})).rejects.toThrow('disabled');
    });
});
`;
    const testPath = path.join(outputDir, 'index.test.ts');
    fs.writeFileSync(testPath, testContent);
    files.push({ path: testPath, content: testContent });
    await (0, audit_1.logToolCall)(RUN_ID, 'codegen.feature', {
        feature: featureName
    }, {
        files_generated: files.length
    });
    return {
        files,
        summary: `Generated ${files.length} files for feature: ${featureName}`
    };
}
/**
 * Generate tests for a feature
 */
async function generateTests(featureName, options) {
    console.log(`[Codegen.generateTests] Generating tests for: ${featureName}`);
    const outputDir = options?.outputDir || path.join(process.cwd(), 'tests', featureName);
    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }
    const files = [];
    const testContent = `import { ${pascalCase(featureName)} } from '../src/${featureName}';

describe('${pascalCase(featureName)}', () => {
    beforeEach(() => {
        // Setup
    });
    
    afterEach(() => {
        // Cleanup
    });
    
    describe('core functionality', () => {
        it('should handle valid input', async () => {
            const result = await ${pascalCase(featureName)}({ test: true });
            expect(result).toBeDefined();
        });
        
        it('should handle invalid input', async () => {
            await expect(${pascalCase(featureName)}(null)).rejects.toThrow();
        });
    });
    
    describe('edge cases', () => {
        it('should handle empty input', async () => {
            const result = await ${pascalCase(featureName)}({});
            expect(result).toBeDefined();
        });
    });
});
`;
    const testPath = path.join(outputDir, `${featureName}.test.ts`);
    fs.writeFileSync(testPath, testContent);
    files.push({ path: testPath, content: testContent });
    await (0, audit_1.logToolCall)(RUN_ID, 'codegen.tests', { featureName }, {
        test_files: files.length
    });
    return { files };
}
// Helper function
function pascalCase(str) {
    return str
        .replace(/[-_](.)/g, (_, c) => c.toUpperCase())
        .replace(/^(.)/, (_, c) => c.toUpperCase());
}
//# sourceMappingURL=codegen.js.map