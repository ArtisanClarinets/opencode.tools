/**
 * MCP Server - Complete JSON-RPC implementation for OpenCode Tools
 * 
 * This server exposes all OpenCode Tools functionality via the Model Context Protocol
 */

import { 
  JsonRpcRequest, 
  JsonRpcResponse, 
  JsonRpcNotification,
  jsonRpcOk, 
  jsonRpcErr, 
  toMcpContent,
  isJsonRpcRequest,
  isJsonRpcNotification
} from './mcp/defs';
import { TOOL_DEFS, getToolHandler } from './mcp/registry';

// Set MCP mode and patch console to prevent stdout pollution
if (typeof process !== 'undefined') {
  process.env.OPENCODE_MCP = '1';
  
  // Patch console methods to write to stderr instead of stdout
  const originalLog = console.log;
  const originalInfo = console.info;
  const originalDebug = console.debug;
  const originalWarn = console.warn;
  
  console.log = (...args) => originalLog.call(console, ...args.map(arg => 
    typeof arg === 'string' ? arg : JSON.stringify(arg, null, 2)
  ));
  
  console.info = (...args) => originalInfo.call(console, ...args.map(arg => 
    typeof arg === 'string' ? arg : JSON.stringify(arg, null, 2)
  ));
  
  console.debug = (...args) => originalDebug.call(console, ...args.map(arg => 
    typeof arg === 'string' ? arg : JSON.stringify(arg, null, 2)
  ));
  
  console.warn = (...args) => originalWarn.call(console, ...args.map(arg => 
    typeof arg === 'string' ? arg : JSON.stringify(arg, null, 2)
  ));
  
  // Keep console.error as-is (already writes to stderr)
}

/**
 * Handle JSON-RPC method calls
 */
async function handleMethod(method: string, params: unknown, id: string | number): Promise<JsonRpcResponse> {
  try {
    switch (method) {
      case 'initialize':
        return handleInitialize(params, id);
      
      case 'tools/list':
        return handleToolsList(params, id);
      
      case 'tools/call':
        return await handleToolsCall(params, id);
      
      case 'ping':
        return jsonRpcOk(id, { pong: true });
      
      default:
        return jsonRpcErr(id, -32601, `Method not found: ${method}`);
    }
  } catch (error) {
    return jsonRpcErr(id, -32000, error instanceof Error ? error.message : String(error));
  }
}

/**
 * Handle initialize request
 */
function handleInitialize(params: unknown, id: string | number): JsonRpcResponse {
  const protocolVersion = (params as any)?.protocolVersion;
  
  // Support multiple protocol versions
  const supportedVersions = ['2025-06-18', '1.0'];
  
  return jsonRpcOk(id, {
    protocolVersion: supportedVersions.includes(protocolVersion) ? protocolVersion : '2025-06-18',
    capabilities: {
      tools: {
        listChanged: false
      }
    },
    serverInfo: {
      name: 'opencode-tools-mcp',
      version: '1.0.0'
    }
  });
}

/**
 * Handle tools/list request
 */
function handleToolsList(params: unknown, id: string | number): JsonRpcResponse {
  // Optional cursor support (we return all tools)
  const cursor = (params as any)?.cursor;
  
  return jsonRpcOk(id, {
    tools: TOOL_DEFS,
    nextCursor: null // All tools returned in one call
  });
}

/**
 * Handle tools/call request
 */
async function handleToolsCall(params: unknown, id: string | number): Promise<JsonRpcResponse> {
  const toolCall = params as { name: string; arguments: Record<string, unknown> };
  
  if (!toolCall?.name) {
    return jsonRpcErr(id, -32602, 'Invalid params: name is required');
  }
  
  const handler = getToolHandler(toolCall.name);
  if (!handler) {
    return jsonRpcErr(id, -32602, `Tool not found: ${toolCall.name}`);
  }
  
  try {
    const result = await handler(toolCall.arguments || {});
    return jsonRpcOk(id, toMcpContent(result));
  } catch (error) {
    return jsonRpcErr(id, -32000, error instanceof Error ? error.message : String(error));
  }
}

/**
 * Handle JSON-RPC notifications
 */
async function handleNotification(method: string, params: unknown): Promise<void> {
  switch (method) {
    case 'notifications/initialized':
      // Server is initialized, can perform any post-initialization setup
      break;
      
    default:
      // Ignore unknown notifications
      break;
  }
}

/**
 * Main MCP server implementation
 */
export async function main(): Promise<void> {
  const stdin = process.stdin;
  const stdout = process.stdout;
  
  let buffer = '';
  let requestId = 0;
  
  // Set up stdin for line-by-line reading
  stdin.setEncoding('utf8');
  stdin.resume();
  
  stdin.on('data', async (chunk: string) => {
    buffer += chunk;
    
    // Process complete lines
    const lines = buffer.split('\n');
    buffer = lines.pop() || ''; // Keep incomplete line in buffer
    
    for (const line of lines) {
      if (!line.trim()) continue;
      
      try {
        const message = JSON.parse(line);
        
        if (isJsonRpcRequest(message)) {
          // Handle request
          const response = await handleMethod(message.method, message.params, message.id);
          stdout.write(JSON.stringify(response) + '\n');
          
        } else if (isJsonRpcNotification(message)) {
          // Handle notification
          await handleNotification(message.method, message.params);
          
        } else {
          // Invalid message format
          const response = jsonRpcErr(++requestId, -32700, 'Parse error');
          stdout.write(JSON.stringify(response) + '\n');
        }
        
      } catch (error) {
        // JSON parse error or other error
        const response = jsonRpcErr(++requestId, -32700, error instanceof Error ? error.message : 'Parse error');
        stdout.write(JSON.stringify(response) + '\n');
      }
    }
  });
  
  // Handle stdin end
  stdin.on('end', () => {
    process.exit(0);
  });
  
  // Handle errors
  stdin.on('error', (error) => {
    console.error('Stdin error:', error);
    process.exit(1);
  });
  
  // Keep the process alive
  process.on('SIGINT', () => {
    process.exit(0);
  });
  
  process.on('SIGTERM', () => {
    process.exit(0);
  });
}

// Export the main function and other utilities
export { cto_sweep } from './mcp-server-legacy';